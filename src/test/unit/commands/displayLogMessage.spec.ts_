import { Range, Selection, TextDocument, TextEditor, window } from 'vscode';
import { describe, expect, it, vi } from 'vitest';
import { displayLogMessageCommand } from '@/commands/displayLogMessage';
import { GeneralDebugMessage } from '@/debug-message';
import { ExtensionProperties } from '@/typings';
import { instanceDebugMessage } from '@/utils/instanceDebugMessage';

vi.mock('vscode');

describe.todo('displayLogMessageCommand', () => {
  let mockEditor: TextEditor;
  let mockDocument: TextDocument;
  let mockSelection: Selection;
  let mockRange: Range;
  let mockDebugMessage: GeneralDebugMessage;
  let mockExtensionProperties: ExtensionProperties;
  let getTabSizeStub: () => number;

  beforeEach(() => {
    mockDocument = {
      getText: vi.fn(),
      getWordRangeAtPosition: vi.fn(),
    };

    mockSelection = {
      active: {
        line: 1,
      },
    };

    mockRange = {
      start: {
        line: 1,
      },
      end: {
        line: 2,
      },
    };

    mockEditor = {
      selections: [mockSelection],
      document: mockDocument,
      edit: vi.fn(),
    };

    mockExtensionProperties = {
      wrapLogMessage: false,
      logMessagePrefix: 'ðŸš€',
      logMessageSuffix: ':',
      addSemicolonInTheEnd: true,
      insertEmptyLineBeforeLogMessage: false,
      insertEmptyLineAfterLogMessage: false,
      quote: '"',
      delimiterInsideMessage: '~',
      includeFileNameAndLineNum: true,
      logFunction: {},
    };

    mockDebugMessage = {
      insertMessage: vi.fn(),
    };

    vi.fn(window, 'activeTextEditor').get(() => mockEditor);

    getTabSizeStub = vi.fn().returns(2);
    vi.fn(getTabSize, 'getTabSize').returns(getTabSizeStub);

    vi.fn(instanceDebugMessage, 'instanceDebugMessage').returns(mockDebugMessage);
  });

  afterEach(() => {});

  it('åº”è¯¥ç›´æŽ¥è¿”å›žå½“æ²¡æœ‰æ´»åŠ¨ç¼–è¾‘å™¨æ—¶', async () => {
    vi.fn(window, 'activeTextEditor').get(() => undefined);

    const command = displayLogMessageCommand();
    await command.handler(mockExtensionProperties);

    expect(mockDocument.getWordRangeAtPosition.called).to.be.false;
    expect(mockEditor.edit.called).to.be.false;
  });

  it('åº”è¯¥è¿”å›žè°ƒç”¨å½“é€‰ä¸­å­—ç¬¦ä¸²æ—¶', async () => {
    mockDocument.getWordRangeAtPosition.returns(mockRange);
    mockDocument.getText.withArgs(mockRange).returns('foo');

    const command = displayLogMessageCommand();
    await command.handler(mockExtensionProperties);

    expect(mockDebugMessage.insertMessage.calledOnce).to.be.true;
    expect(mockDebugMessage.insertMessage.getCall(0).args).to.deep.equal([
      mockEditor.edit,
      mockDocument,
      'foo',
      1,
      2,
      mockExtensionProperties,
    ]);
  });

  it('åº”è¯¥ç›´æŽ¥è¿”å›žå½“æ²¡æœ‰é€‰ä¸­å­—ç¬¦æ—¶æˆ–å…‰æ ‡æ²¡æœ‰åœ¨å­—ç¬¦ä¸²æ—è¾¹æ—¶', async () => {
    mockDocument.getText.returns('');

    const command = displayLogMessageCommand();
    await command.handler(mockExtensionProperties);

    expect(mockDebugMessage.insertMessage.called).to.be.false;
  });
});
